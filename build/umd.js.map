{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "lib/_stream_0.js",
    "lib/linter.js",
    "lib/logger.js",
    "lib/runner.js",
    "lib/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\nconst tests = module.exports = new Map();\n    let name;\n    const { $, $$ } = require('./utils');\n    const defineTest = test => tests.set(name, test);\n    name = \"alt\";\ndefineTest({\n  message: 'missing alt attribute',\n  selector: 'img:not([alt])',\n});\nname = \"fieldset-legend\";\ndefineTest({\n  message: 'All fieldsets must have a legend',\n  selector: 'fieldset',\n  filter: el => {\n    const first = el.firstElementChild;\n    return first && first.matches('legend') && first.textContent.trim();\n  },\n});\nname = \"headings\";\ndefineTest({\n  message: 'Headings must be nested correctly',\n  selector: 'h2,h3,h4,h5,h6',\n  allowed: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n  filter(el) {\n    let cursor = el;\n    const level = +el.nodeName[1];\n    do {\n      cursor = cursor.previousElementSibling || cursor.parentElement;\n      if (cursor && cursor.matches(this.allowed.join())) {\n        return !cursor.matches(this.allowed.slice(level - 1));\n      }\n    } while (cursor);\n    return false;\n  },\n});\nname = \"label\";\ndefineTest({\n  message: 'all form elements must have a label',\n  selector: 'input,select,textarea',\n  filter: el => {\n    if (/^(?:submit|reset|button|image|hidden)$/.test(el.type)) {\n      return true;\n    }\n\n    let label;\n\n    if (el.hasAttribute('aria-labelledby')) {\n      label = $(`#${el.getAttribute('aria-labelledby')}`);\n    }\n\n    if (!label && el.hasAttribute('aria-label')) {\n      label = { textContent: el.getAttribute('aria-label') };\n    }\n\n    if (!label) {\n      if (el.id) {\n        label = $(`label[for=\"${el.id}\"]`);\n      }\n      if (!label) {\n        label = el.closest('label');\n      }\n    }\n\n    return label && label.textContent.trim();\n  },\n});\nname = \"label-associated\";\ndefineTest({\n  message: 'all labels must be linked to a control',\n  selector: 'label',\n  filter: el => el.htmlFor && document.getElementById(el.htmlFor),\n});\nname = \"legend\";\ndefineTest({\n  message: 'All legends must be the first child of a fieldset',\n  selector: 'legend',\n  filter: el => el === el.parentNode.firstElementChild,\n});\nname = \"radio-fieldset\";\ndefineTest({\n  message: 'All radio inputs must be within a fieldset',\n  selector: 'input[type=radio]',\n  filter: el => el.closest('fieldset'),\n});\nname = \"unique-id\";\ndefineTest({\n  message: 'id is not unique',\n  selector: '[id]',\n  filter: el => !el.id || $$(`#${el.id}`).length === 1,\n});\n  ",
    "\"use strict\";\nconst Runner = require('./runner');\nconst Logger = require('./logger');\nconst tests = require('./tests');\nconst utils = require('./utils');\n\nconst Linter = module.exports = class AccessibilityLinter extends Runner {\n  constructor(options) {\n    options = options || {};\n    options.logger = options.logger || new Logger();\n    options.tests = options.tests || tests;\n    super(options);\n\n    this.root = options.root || document;\n  }\n\n  /**\n   * Start looking for issues\n   */\n  observe() {\n    this.run(this.root);\n    this.observer = utils.observe(this.run.bind(this), this.root);\n  }\n\n  /**\n   * Stop looking for issues\n   */\n  stopObserving() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n};\n\nLinter.Logger = Logger;\nLinter.tests = tests;\n",
    "\"use strict\";\n/* eslint-disable no-console */\nclass Logger {\n  message(message, el) {\n    if (typeof message === 'string') {\n      return message;\n    }\n    return message(el);\n  }\n\n  error(test, el) {\n    console.error(this.message(test.message, el), el);\n  }\n\n  warn(test, el) {\n    console.warn(this.message(test.message, el), el);\n  }\n}\n",
    "\"use strict\";\nconst { $$ } = require('./utils');\n\nconst dataAttr = 'allylint';\n\nconst addToSetArray = (set, key, value) => set.set(key, (set.get(key) || []).concat(value));\nconst isInSetArray = (set, key, value) => (set.get(key) || []).includes(value);\nconst cssEscape = value => value.replace(/\"/g, '\\\\\"');\n\nmodule.exports = class Runner {\n  constructor(config) {\n    this.tests = config.tests;\n    this.whitelist = config.whitelist || {};\n    this.logger = config.logger;\n\n    // Elements and issues already reported\n    this.reported = new WeakMap();\n    // Elements that are whitelisted\n    this.whitelisted = new WeakMap();\n    // Elements with ignore attributes\n    this.ignored = new WeakMap();\n  }\n\n  /**\n   * Run all the tests\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  run(context) {\n    this.tests\n      .filter(test => !(test.globalOnly && context))\n      .forEach(test => this.runTest(test, context));\n  }\n\n  /**\n   * Run a single test\n   * @param {Object} test The test to run\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  runTest(test, context) {\n    $$(test.selector, context)\n      .filter(el => this.filterIgnoreAttribute(el, test.name))\n      .filter(el => this.filterWhitelist(el, test.name))\n      .filter(el => !isInSetArray(this.reported, el, test.name))\n      .filter(el => (test.filter ? !test.filter(el) : true))\n      .forEach(el => {\n        this.logger.error(test, el);\n        addToSetArray(this.reported, el, test.name);\n      });\n  }\n\n  /**\n   * Filter elements on the whitelist\n   */\n  filterWhitelist(el, testName) {\n    const whitelist = this.whitelist;\n\n    if (isInSetArray(this.whitelisted, el, testName)) {\n      return false;\n    }\n\n    const isWhitelisted = Object.keys(whitelist).some(selector => {\n      const testList = whitelist[selector];\n      if (testList && !testList.includes(testName)) {\n        return false;\n      }\n      return el.matches(selector);\n    });\n\n    if (isWhitelisted) {\n      addToSetArray(this.whitelisted, el, testName);\n      return false;\n    }\n    return true;\n  }\n\n  filterIgnoreAttribute(el, testName) {\n    if (isInSetArray(this.ignored, el, testName)) {\n      return false;\n    }\n\n    const ignore = el.matches(\n      `[data-${dataAttr}-ignore=\"\"],[data-${dataAttr}-ignore~=\"${cssEscape(testName)}\"]`\n    );\n\n    if (ignore) {\n      addToSetArray(this.ignored, el, testName);\n      return false;\n    }\n\n    return true;\n  }\n};\n",
    "\"use strict\";\n/**\n * Find DOM nodes from a selector.  The found node can include the supplied context\n * @param {String|NodeList} selector\n * @param {HTMLElement} [context]\n */\nexports.$$ = function $$(selector, context) {\n  const root = context || document;\n  const els = Array.from(root.querySelectorAll(selector));\n  if (context && context instanceof Element && context.matches(selector)) {\n    els.push(context);\n  }\n  return els;\n};\n\nexports.$ = function $(selector, context) {\n  return exports.$$(selector, context)[0];\n};\n\n/**\n * Observe for child list mutations\n * @param {Function} fn function to call for each mutation\n */\nexports.observe = function mutationObserver(fn, root) {\n  const observer = new MutationObserver(mutations => {\n    mutations.forEach(mutation => {\n      Array.from(mutation.addedNodes)\n        .filter(node => node.nodeType === Node.ELEMENT_NODE)\n        .forEach(node => fn(node));\n    });\n  });\n  observer.observe(root, { subtree: true, childList: true });\n  return observer;\n};\n"
  ]
}