{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "lib/_stream_0.js",
    "lib/index.js",
    "lib/linter.js",
    "lib/logger.js",
    "lib/runner.js",
    "lib/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\nconst tests = module.exports = [];\n    const defineTest = test => tests.push(test);\n    defineTest({\n  name: 'missing alt attribute',\n  selector: 'img:not([alt])',\n});\n\n  ",
    "\"use strict\";\nconst Linter = require('./linter');\n\nconst config = window.accessibilityLinterConfig || {};\nconst scriptElement = document.currentScript;\nif (scriptElement) {\n  eval(`!function(){${scriptElement.textContent}}()`); // eslint-disable-line no-eval\n  if (!('whitelist' in config)) {\n    config.whitelist = scriptElement.dataset.whitelist;\n  }\n}\n\nconst linter = new Linter(config);\nif (/^(:?interactive|complete)$/.test(document.readyState)) {\n  // Document already loaded\n  linter.observe();\n} else {\n  document.addEventListener('DOMContentLoaded', () => linter.observe());\n}\n\nmodule.exports = linter;\n",
    "\"use strict\";\nconst Runner = require('./runner');\nconst Logger = require('./logger');\nconst tests = require('./tests');\nconst utils = require('./utils');\n\nconst Linter = module.exports = class AccessibilityLinter extends Runner {\n  constructor(options) {\n    options = options || {};\n    options.logger = options.logger || new Logger();\n    options.tests = options.tests || tests;\n    super(options);\n\n    this.root = options.root || document;\n  }\n\n  /**\n   * Start looking for issues\n   */\n  observe() {\n    this.run(this.root);\n    this.observer = utils.observe(this.run.bind(this), this.root);\n  }\n\n  /**\n   * Stop looking for issues\n   */\n  stopObserving() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n};\n\nLinter.Logger = Logger;\nLinter.tests = tests;\n",
    "\"use strict\";\n/* eslint-disable no-console */\nmodule.exports = class Logger {\n  message(message, el) {\n    if (typeof message === 'string') {\n      return message;\n    }\n    return message(el);\n  }\n\n  error(test, el) {\n    console.error(this.message(test.message, el), el);\n  }\n\n  warn(test, el) {\n    console.warn(this.message(test.message, el), el);\n  }\n};\n",
    "\"use strict\";\nconst select = require('./utils').select;\n\nconst dataAttr = 'allylint';\n\nconst addToSetArray = (set, key, value) => set.set(key, (set.get(key) || []).concat(value));\nconst isInSetArray = (set, key, value) => (set.get(key) || []).includes(value);\nconst cssEscape = value => value.replace(/\"/g, '\\\\\"');\n\nmodule.exports = class Runner {\n  constructor(config) {\n    this.tests = config.tests;\n    this.whitelist = config.whitelist || {};\n    this.logger = config.logger;\n\n    // Elements and issues already reported\n    this.reported = new WeakMap();\n    // Elements that are whitelisted\n    this.whitelisted = new WeakMap();\n    // Elements with ignore attributes\n    this.ignored = new WeakMap();\n  }\n\n  /**\n   * Run all the tests\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  run(context) {\n    this.tests\n      .filter(test => !(test.globalOnly && context))\n      .forEach(test => this.runTest(test, context));\n  }\n\n  /**\n   * Run a single test\n   * @param {Object} test The test to run\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  runTest(test, context) {\n    select(test.selector, context)\n      .filter(el => this.filterIgnoreAttribute(el, test.name))\n      .filter(el => this.filterWhitelist(el, test.name))\n      .filter(el => !isInSetArray(this.reported, el, test.name))\n      .filter(el => (test.filter ? !test.filter(el) : true))\n      .forEach(el => {\n        this.logger.error(test, el);\n        addToSetArray(this.reported, el, test.name);\n      });\n  }\n\n  /**\n   * Filter elements on the whitelist\n   */\n  filterWhitelist(el, testName) {\n    const whitelist = this.whitelist;\n\n    if (isInSetArray(this.whitelisted, el, testName)) {\n      return false;\n    }\n\n    const isWhitelisted = Object.keys(whitelist).some(selector => {\n      const testList = whitelist[selector];\n      if (testList && !testList.includes(testName)) {\n        return false;\n      }\n      return el.matches(selector);\n    });\n\n    if (isWhitelisted) {\n      addToSetArray(this.whitelisted, el, testName);\n      return false;\n    }\n    return true;\n  }\n\n  filterIgnoreAttribute(el, testName) {\n    if (isInSetArray(this.ignored, el, testName)) {\n      return false;\n    }\n\n    const ignore = el.matches(\n      `[data-${dataAttr}-ignore=\"\"],[data-${dataAttr}-ignore~=\"${cssEscape(testName)}\"]`\n    );\n\n    if (ignore) {\n      addToSetArray(this.ignored, el, testName);\n      return false;\n    }\n\n    return true;\n  }\n};\n",
    "\"use strict\";\n/**\n * Find DOM nodes from a selector.  The found node can include the supplied context\n * @param {String|NodeList} selector\n * @param {HTMLElement} [context]\n */\nexports.select = function select(selector, context) {\n  const root = context || document;\n  const els = Array.from(root.querySelectorAll(selector));\n  if (context && context instanceof Element && context.matches(selector)) {\n    els.push(context);\n  }\n  return els;\n};\n\n/**\n * Observe for child list mutations\n * @param {Function} fn function to call for each mutation\n */\nexports.observe = function mutationObserver(fn, root) {\n  const observer = new MutationObserver(mutations => {\n    mutations.forEach(mutation => {\n      Array.from(mutation.addedNodes)\n        .filter(node => node.nodeType === Node.ELEMENT_NODE)\n        .forEach(node => fn(node));\n    });\n  });\n  observer.observe(root, { subtree: true, childList: true });\n  return observer;\n};\n"
  ]
}