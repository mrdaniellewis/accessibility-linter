{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "lib/_stream_0.js",
    "lib/_stream_1.js",
    "lib/index.js",
    "lib/linter.js",
    "lib/logger.js",
    "lib/runner.js",
    "lib/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/OA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\n\n    const { $, $$, cssEscape } = require('./utils');\n    module.exports = new Map([\n      [\n        \"alt\",\n        Object.assign(\n          { name: \"alt\", doc: \"alt\" },\n          {\n  message: 'missing alt attribute',\n  selector: 'img:not([alt])',\n}\n        ),\n      ],[\n        \"fieldset/checkbox-groups-in-fieldset\",\n        Object.assign(\n          { name: \"fieldset/checkbox-groups-in-fieldset\", doc: \"fieldset\" },\n          {\n  message: 'All checkbox groups must be within a fieldset',\n  selector: 'input[type=checkbox]',\n  filter: (el) => {\n    if (!el.name) {\n      return true;\n    }\n\n    if (el.form && !(el.form.elements[el.name] instanceof NodeList)) {\n      return true;\n    }\n\n    if (!el.form && $$(`input[type=checkbox][name=\"${cssEscape(el.name)}\"]`).filter(elm => !elm.form).length === 1) {\n      return true;\n    }\n\n    return el.closest('fieldset');\n  },\n}\n        ),\n      ],[\n        \"fieldset/fieldset-has-legend\",\n        Object.assign(\n          { name: \"fieldset/fieldset-has-legend\", doc: \"fieldset\" },\n          {\n  message: 'All fieldsets must have a legend',\n  selector: 'fieldset',\n  filter: (el) => {\n    const first = el.firstElementChild;\n    return first && first.matches('legend') && first.textContent.trim();\n  },\n}\n        ),\n      ],[\n        \"fieldset/legend-has-fieldset\",\n        Object.assign(\n          { name: \"fieldset/legend-has-fieldset\", doc: \"fieldset\" },\n          {\n  message: 'All legends must be the first child of a fieldset',\n  selector: 'legend',\n  // Detecting text nodes isn't worth it\n  filter: el => el.parentNode.matches('fieldset') && el === el.parentNode.firstElementChild,\n}\n        ),\n      ],[\n        \"fieldset/radios-in-fieldset\",\n        Object.assign(\n          { name: \"fieldset/radios-in-fieldset\", doc: \"fieldset\" },\n          {\n  message: 'All radio inputs must be within a fieldset',\n  selector: 'input[type=radio]',\n  filter: el => el.closest('fieldset'),\n}\n        ),\n      ],[\n        \"headings\",\n        Object.assign(\n          { name: \"headings\", doc: undefined },\n          {\n  message: 'Headings must be nested correctly',\n  selector: 'h2,h3,h4,h5,h6',\n  allowed: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n  previous(el) {\n    let cursor = el.previousElementSibling;\n    while (cursor && cursor.lastElementChild) {\n      cursor = cursor.lastElementChild;\n    }\n    return cursor;\n  },\n  filter(el) {\n    let cursor = el;\n    const level = +el.nodeName[1];\n    do {\n      cursor = this.previous(cursor) || cursor.parentElement;\n      if (cursor && cursor.matches(this.allowed.join())) {\n        return cursor.matches(this.allowed.slice(level - 2).join(','));\n      }\n    } while (cursor);\n    return false;\n  },\n}\n        ),\n      ],[\n        \"label/inputs-are-labelled\",\n        Object.assign(\n          { name: \"label/inputs-are-labelled\", doc: \"label-inputs-are-labelled\" },\n          {\n  message: 'all form elements must have a label',\n  selector: 'input,select,textarea',\n  filter(el) {\n    if (/^(?:submit|reset|button|image|hidden)$/.test(el.type)) {\n      return true;\n    }\n\n    let label;\n\n    if (el.hasAttribute('aria-labelledby')) {\n      label = $(`#${el.getAttribute('aria-labelledby')}`);\n    }\n\n    if (!label && el.hasAttribute('aria-label')) {\n      label = { textContent: el.getAttribute('aria-label') };\n    }\n\n    if (!label) {\n      if (el.id) {\n        label = $(`label[for=\"${cssEscape(el.id)}\"]`);\n      }\n      if (!label) {\n        label = el.closest('label');\n      }\n    }\n\n    return label && label.textContent.trim();\n  },\n}\n        ),\n      ],[\n        \"label/labels-have-inputs\",\n        Object.assign(\n          { name: \"label/labels-have-inputs\", doc: \"label\" },\n          {\n  message: 'all labels must be linked to a control',\n  selector: 'label',\n  filter: el => el.htmlFor && document.getElementById(el.htmlFor),\n}\n        ),\n      ],[\n        \"list-id\",\n        Object.assign(\n          { name: \"list-id\", doc: undefined },\n          {\n  message: 'no datalist found',\n  selector: 'input[list]',\n  filter(el) {\n    const listId = el.getAttribute('list');\n    return listId && $(`datalist[id=\"${cssEscape(listId)}\"]`);\n  },\n}\n        ),\n      ],[\n        \"no-duplicate-anchor-names\",\n        Object.assign(\n          { name: \"no-duplicate-anchor-names\", doc: undefined },\n          {\n  message: 'Name is not unique',\n  selector: 'a[name]',\n  filter(el) {\n    const id = cssEscape(el.name);\n    return id && $$(`a[name=\"${id}\"],[id=\"${id}\"]`).length === 1;\n  },\n}\n        ),\n      ],[\n        \"no-empty-select\",\n        Object.assign(\n          { name: \"no-empty-select\", doc: undefined },\n          {\n  message: 'Selects should have options',\n  selector: 'select',\n  filter: el => $$('option', el).length,\n}\n        ),\n      ],[\n        \"no-links-to-missing-fragments\",\n        Object.assign(\n          { name: \"no-links-to-missing-fragments\", doc: undefined },\n          {\n  message: 'Fragment not found in document',\n  selector: 'a[href*=\"#\"]',\n  removeHash(ob) {\n    return ob.href.replace(/#.*$/, '');\n  },\n  filter(el) {\n    if (this.removeHash(location) !== this.removeHash(el)) {\n      return true;\n    }\n    const id = cssEscape(decodeURI(el.hash.slice(1)));\n    return $(`[id=\"${id}\"],a[name=\"${id}\"]`);\n  },\n}\n        ),\n      ],[\n        \"no-multiple-select\",\n        Object.assign(\n          { name: \"no-multiple-select\", doc: undefined },\n          {\n  message: 'Do not use multiple selects',\n  selector: 'select[multiple]',\n}\n        ),\n      ],[\n        \"no-outside-controls\",\n        Object.assign(\n          { name: \"no-outside-controls\", doc: undefined },\n          {\n  message: 'All controls should be within a form',\n  selector: 'input,textarea,select',\n  filter: el => el.form,\n}\n        ),\n      ],[\n        \"no-reset\",\n        Object.assign(\n          { name: \"no-reset\", doc: undefined },\n          {\n  message: 'Do not use reset buttons',\n  selector: 'input[type=reset],button[type=reset]',\n}\n        ),\n      ],[\n        \"unique-id\",\n        Object.assign(\n          { name: \"unique-id\", doc: undefined },\n          {\n  message: 'id is not unique',\n  selector: '[id]',\n  filter: el => !el.id || $$(`[id=\"${cssEscape(el.id)}\"]`).length === 1,\n}\n        ),\n      ]\n    ]);\n  ",
    "\"use strict\";\nmodule.exports = \"1.0.0\"",
    "\"use strict\";\n/**\n * Entry point for standalone autorunning linter\n */\nconst Linter = require('./linter');\n\nconst config = window.accessibilityLinterConfig || {};\nconst scriptElement = document.currentScript;\nif (scriptElement) {\n  eval(`!function(){${scriptElement.textContent}}()`); // eslint-disable-line no-eval\n  if (!('whitelist' in config)) {\n    config.whitelist = scriptElement.dataset.whitelist;\n  }\n}\n\nconst linter = new Linter(config);\nif (/^(:?interactive|complete)$/.test(document.readyState)) {\n  // Document already loaded\n  linter.observe();\n} else {\n  document.addEventListener('DOMContentLoaded', () => linter.observe());\n}\n\nmodule.exports = linter;\n",
    "\"use strict\";\nconst Runner = require('./runner');\nconst Logger = require('./logger');\nconst tests = require('./tests');\nconst utils = require('./utils');\nconst version = require('./version');\n\nconst Linter = module.exports = class AccessibilityLinter extends Runner {\n  constructor(options) {\n    options = options || {};\n    options.logger = options.logger || new Logger();\n    options.tests = options.tests || tests;\n    super(options);\n\n    this.root = options.root || document;\n  }\n\n  /**\n   * Start looking for issues\n   */\n  observe() {\n    this.run(this.root);\n    this.observer = utils.observe(this.run.bind(this), this.root);\n  }\n\n  /**\n   * Stop looking for issues\n   */\n  stopObserving() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n};\n\nLinter.Logger = Logger;\nLinter.tests = tests;\nLinter.version = version;\n",
    "\"use strict\";\n/* eslint-disable no-console */\nmodule.exports = class Logger {\n  constructor(docLink) {\n    this.docLink = docLink;\n  }\n\n  error(test, el) {\n    console.error.apply(console, this.message(test, el));\n  }\n\n  warn(test, el) {\n    console.warn.apply(console, this.message(test, el));\n  }\n\n  message(test, el) {\n    return [\n      typeof test.message === 'function' ? test.message(el) : test.message,\n      el,\n      this.getLink(test),\n    ].filter(Boolean);\n  }\n\n  getLink(test) {\n    if (!this.docLink || !test.doc) {\n      return null;\n    }\n\n    return `${this.docLink}#${test.doc}`;\n  }\n};\n",
    "\"use strict\";\nconst { $$ } = require('./utils');\n\nconst dataAttr = 'allylint';\n\nconst addToSetArray = (set, key, value) => set.set(key, (set.get(key) || []).concat(value));\nconst isInSetArray = (set, key, value) => (set.get(key) || []).includes(value);\nconst cssEscape = value => value.replace(/\"/g, '\\\\\"');\n\nmodule.exports = class Runner {\n  constructor(config) {\n    this.tests = config.tests;\n    this.whitelist = config.whitelist || {};\n    this.logger = config.logger;\n\n    // Elements and issues already reported\n    this.reported = new WeakMap();\n    // Elements that are whitelisted\n    this.whitelisted = new WeakMap();\n    // Elements with ignore attributes\n    this.ignored = new WeakMap();\n  }\n\n  /**\n   * Run all the tests\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  run(context) {\n    this.tests\n      .forEach((test, name) => this.runTest(test, name, context));\n  }\n\n  /**\n   * Run a single test\n   * @param {Object} test The test to run\n   * @param {HTMLElement} [context] A context to run the tests within\n   */\n  runTest(test, name, context) {\n    $$(test.selector, context)\n      .filter(el => this.filterIgnoreAttribute(el, name))\n      .filter(el => this.filterWhitelist(el, name))\n      .filter(el => !isInSetArray(this.reported, el, name))\n      .filter(el => (test.filter ? !test.filter(el) : true))\n      .forEach((el) => {\n        this.logger.error(test, el);\n        addToSetArray(this.reported, el, name);\n      });\n  }\n\n  /**\n   * Filter elements on the whitelist\n   */\n  filterWhitelist(el, testName) {\n    const whitelist = this.whitelist;\n\n    if (isInSetArray(this.whitelisted, el, testName)) {\n      return false;\n    }\n\n    const isWhitelisted = Object.keys(whitelist).some((selector) => {\n      const testList = whitelist[selector];\n      if (testList && !testList.includes(testName)) {\n        return false;\n      }\n      return el.matches(selector);\n    });\n\n    if (isWhitelisted) {\n      addToSetArray(this.whitelisted, el, testName);\n      return false;\n    }\n    return true;\n  }\n\n  filterIgnoreAttribute(el, testName) {\n    if (isInSetArray(this.ignored, el, testName)) {\n      return false;\n    }\n\n    const ignore = el.matches(\n      `[data-${dataAttr}-ignore=\"\"],[data-${dataAttr}-ignore~=\"${cssEscape(testName)}\"]`\n    );\n\n    if (ignore) {\n      addToSetArray(this.ignored, el, testName);\n      return false;\n    }\n\n    return true;\n  }\n};\n",
    "\"use strict\";\n/**\n * Find DOM nodes from a selector.  The found node can include the supplied context\n * @param {String|NodeList} selector\n * @param {HTMLElement} [context]\n */\nexports.$$ = function $$(selector, context) {\n  const root = context || document;\n  const els = Array.from(root.querySelectorAll(selector));\n  if (context && context instanceof Element && context.matches(selector)) {\n    els.push(context);\n  }\n  return els;\n};\n\nexports.$ = function $(selector, context) {\n  return exports.$$(selector, context)[0];\n};\n\nexports.cssEscape = function cssEscape(name) {\n  return name.replace(/[\"\\\\]/g, '\\\\$&');\n};\n\n/**\n * Observe for child list mutations\n * @param {Function} fn function to call for each mutation\n */\nexports.observe = function mutationObserver(fn, root) {\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      Array.from(mutation.addedNodes)\n        .filter(node => node.nodeType === Node.ELEMENT_NODE)\n        .forEach(node => fn(node));\n    });\n  });\n  observer.observe(root, { subtree: true, childList: true });\n  return observer;\n};\n"
  ]
}